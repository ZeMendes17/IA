\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{geometry}
\usepackage{graphicx}
\graphicspath{ {./Images/} }
\usepackage[shortlabels]{enumitem}
\usepackage{fancyhdr}
\usepackage{ulem}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\renewcommand\maketitlehooka{\null\mbox{}\vfill} %para centralizar verticalmente
\renewcommand\maketitlehookd{\vfill\null}
\pagestyle{fancy}
\fancyhf{}
\rfoot{\thepage}
\lfoot{ \includegraphics[scale=0.01]{UA.jpg} José Mendes 107188 LEI}
\geometry{
  a4paper,
  headheight=4cm,
  top=5.5cm,
  bottom=4.5cm,
  footskip=4cm
}


\title{Inteligência Artificial}
\author{José Mendes 107188}
\date{2023/2024}

\begin{document}


\begin{titlepage}
    \maketitle
    \begin{center}
        \includegraphics[scale=0.4]{UA.png}
    \end{center}
    \thispagestyle{empty} %remove o count da pagina
\end{titlepage}

\pagebreak

\section{Noções de Programação Declarativa}

\subsection{Programação Declarativa}

A Programação Declarativa abstrai-se da implementação, focando-se
apenas na descrição do que se pretende fazer, enquanto faz uso de dois
paradigmas:
\begin{itemize}
  \item \textbf{Programação Funcional}, baseado em funções/calculo-lambda, a entidade central é a função;
  \item \textbf{Programação em Lógica}, baseado em lógica de primeira ordem, a entidade central é o predicado;
\end{itemize}


\subsection{Paradigma Imperativo}

O fluxo de operações é especialmente sequenciado de operações com
foco na forma como as tarefas são executadas (\textbf{instrução}). Podemos \textbf{alterar
o conteúdo em memória} e ainda (instruções de afetação/atribuição) e ainda
\textbf{realizar análise de casos} (if-then-else, switch/case, \dots), \textbf{processamento
iterativo} (while, repeat, for, \dots) e ter associados \textbf{sub-programas} (procedimentos,
funções).

\begin{flushleft}
\textbf{Exemplo:} SQL é uma linguagem declarativa, uma vez que nos seus comandos apenas descrevemos o que queremos obter.
Assim, o programador é abstraído da forma como as operações são executadas na prática, ficando essa tarefa a cargo
do compilador.
\end{flushleft}

\subsection{Paradigma Declarativo}

\begin{center}
\includegraphics[scale=0.5]{1}
\end{center}

A sua origem data da segunda metade do século XX, mas ainda hoje é amplamente usada e
até está em crescimento em áreas como a Inteligência Artifical.

\pagebreak

\subsection{Programação Funcional}

Possibilidade de definir funções localmente e sem nome. Por exemplo as
funções lambda presentes em Lisp e Python.

\subsection{Programação em Lógica}

Um programa é uma teoria sobre um domínio. Por exemplo, temos
\textbf{socrates é um homem}, $homem(socrates)$ e, um \textbf{homem é mortal}, $homem(X) :- \hspace{1mm} mortal(X)$.
Se perguntarmos se \textbf{socrates é mortal}, $mortal(socrates)$, a resposta é \uline{sim}.

\subsection{Atitude do programador}

A programação declarativa, dada a sua elevada expressividade, é pouco
compatível com aproximações empíricas (ou seja, tentativa e erro) à programação.
Primeiro é preciso pensar bem na estrutura do problema antes de começar a teclar.

\vspace{2mm}

\begin{flushleft}
  \textbf{Passos a seguir:} Perceber o problema $\rightarrow$ Desenhar o programa $\rightarrow$
  Escrevê-lo $\rightarrow$ Rever e testar
\end{flushleft}

\subsection{Características da Programação Funcional}

\begin{itemize}
  \item A entidade central é a função;
  \item A noção de função é diretamete herdada da matemática (ao contrário das
  linguagens imperativas, que pode ser muito diferente);
  \item A estrutura de controlo fundamental é a "aplicação de funções";
  \item A noção de "tipo da função" captura a noção matemática de
  domínio (de entrada e saída);
  \item Os elementos do domínio de entrada e saída podem ser funções;
\end{itemize}

\subsection{Função}

Tem valores de entrada (domínio) e valores de saída (contradomínio).

\begin{center}
\includegraphics[scale=0.4]{2}
\end{center}

\subsection{Programação em Lógica}

Um programa numa linguagem baseada em lógica representa uma teoria sobre um
problems. Um programa é uma sequência de frases ou fórmulas representando
\textbf{factos} (informação sobre objetos do problema/domínio de aplicação) e \textbf{regras}
(leis gerais sobre esse problema/domínio). Implicitamente as frases estão reunidas
nume grande conjunção, e cada frase está universalmente quantificada. Portanto,
\textbf{programação declarativa}.

\pagebreak

\section{Programação ao estilo funcional em Python}

\subsection{Python}

Criada no final dos anos 90, é uma linguagem de programação interpretada,
iterativa, portável, funcional, orientada a objetos e de implementação aberta.
Tem como principais objetivos: simplicidade sem prejuizo da utilidade,
programação modular, legibilidade, desenvolvimento rápido, facilidade de integração,
nomeadamente com outras linguagens. Apresenta-se como uma linguagem \textbf{multi-paradigma}:
\begin{itemize}
  \item \textbf{Programação funcional:} Expressões lambda, funções de ordem superior,
  listas com sintaxe simples, iteradores, \dots
  \item \textbf{Programação OO:} Classes, objetos, métodos, herança, \dots
  \item \textbf{Programação imperativa/modular:} Atribuição, sequências,
  condicionais, ciclos, \dots
\end{itemize}

\subsubsection{Python vs Java}

Comparativamente ao JAVA revela-se menos consisa porque os espaços são sintaticamente
relevantes e o código, não compilado para código nativo (interpretado), demora mais tempo a
executar (diferença residual), no entanto apresenta uma maior facilidade de desenvolvimento e
legibilidade.

\subsubsection{Áreas de aplicação}

As principais áreas de aplicação são: interligação de sistemas, aplicações gráficas,
aplicações para bases de dados, multimédia, internet protocol/web e
robótica e inteligência artificial.

\subsection{Dados, ou "objetos"}

\begin{flushleft}
  \textbf{Objeto:} no contexto de Pyhton, esta designação é
  aplicada a qualquer dado que possa ser armazenado
  numa variável, ou passado como parâmetro a uma
  função.
\end{flushleft}

Cada objeto é caracterizado por uma identidade/referência (identifica a posição
de memória onde está armazenado), um tipo e um valor. Alguns tipos de
objetos podem ter atributos e métodos, outros (classes) podem ter
sub-tipos (sub-classes).

\begin{center}
  \includegraphics[scale=0.3]{3}
\end{center}

Alguns destes são imutáveis, como as \textbf{str} e \textbf{tuple}. Para determinar o tipo de um objeto utiliza-se a função pré-definida \textbf{type()}.

\pagebreak

\subsection{Variáveis}

As variáveis guardam objetos, mas não são declaradas (inicializadas apenas) nem têm tipos
associados (o tipo é do objeto!). Praticamente tudo pode ser atribuido a uma variável, incluindo
funções, módulos e classes. Similar as linguagens imperativas, e ao contrário das
funcionais, o valor de uma variável pode ser alterado. Não se pode ler o valor de uma variável
se este não tiver sido previamente inicializado.

\subsection{Intrução de atribuição}

Tal como é habitual na programação imperativa, e ao
contrário do habitual na programação declarativa,
Python possui instrução de atribuição.

\begin{flushleft}
  \textbf{Exemplo:}
  \begin{lstlisting}
    n = 10
    a = b = c = 0
    x = 7.25
    cad = "cadeia"
    t = (n, x)
    l = [1, 2, 'quatro', 5.0]
  \end{lstlisting}
\end{flushleft}

Pode user a operação de atribuição para decompor estruturas:
\begin{lstlisting}
  triplo = (1, 2, 3)
  (i, j, k) = triplo
\end{lstlisting}

\subsection{Operadores}

Operadores comuns matemáticos e lógicos. É importante saber que objetos de
tipos diferentes nunca são iguais (exceto os diferentes tipos de números).

\subsubsection{Operadores lógicos}

Na conjunção e disjunção, o segundo elemento só é avaliado de for necessário para determinar
o resultado.

\begin{lstlisting}
  if False and a: # a nao e avaliado
    ...

  if True or a: # a nao e avaliado
    ...
\end{lstlisting}

\pagebreak

\subsection{Acesso a sequências}

Os elementos das sequências são acedidos
através de índices inteiros consecutivos (primeiro elemento tem índice 0).

\vspace{2mm}

É possível extrair “fatias” das sequências. A indexação é circular, pelo que podemos aceder a
índices negativos.

\begin{lstlisting}
  # [inf:sup] retorna a sequencia entre os indices inf e sup-1 (uma opia da lista)

  # Para fazer uma copia integral da lista usa-se [:]
\end{lstlisting}

\begin{flushleft}
  \textbf{Detalhe importante:}  instrução de atribuição, em vez de copiar valores, limita-se
  a associar um dado identificador a um dado objecto. Desta forma, a atribuição
  da variável x a uma variável y, apenas tem como resultado associar y
  ao mesmo objecto que x já estava associada. No caso dos objetos
  mútaveis, temos de ter cuidado:

  \begin{lstlisting}
    a = [1, 2, 3]
    b = a
    b[1:2] = []
    print(a) # [1, 3]
  \end{lstlisting}
\end{flushleft}

\subsection{Definição de funções}

Funções sem return, retornam None, são também conhecidas como procedimentos. As funções podem
ser recursivas e são objetos do tipo \textbf{function}.

\vspace{2mm}

Os parâmetros são passados às funções segundo um mecânismo "passagem por valor"
("call by value"). \uline{Os parâmetros são passados por referêcia, não cópias!}. 

\vspace{2mm}

Se atribuirmos um novo objeto a uma variável passada por
parâmetro, essa atribuição ocorre apenas no espaço de nomes da função (imagem à
esquerda). Se modificarmos um objeto passado por parâmetro (por
exemplo, apagar um elemento de uma lista), isto não altera a
referência do objeto, e portanto vai permanecer após o
retorno da função (imagem à direita).

\begin{center}
  \includegraphics[scale=0.3]{4}
\end{center}

O problema anterior resolve-se trabalhando sobre uma cópia local,
no caso de uma lista l, podemos usar l[:], que dá uma cópia integral.

\pagebreak

Podemos passar parâmetros com valores por defeito, podendo se, na chamada,
omitir alguns parâmetros.

\begin{lstlisting}
  def abc(arg1, arg2=True, arg3=None):
    ...
  # Quando so queremos passar um dos args por defeito devemos indicar o seu nome
  abc(1, arg3=3)
\end{lstlisting}

\subsection{Funções Recursivas}

\begin{lstlisting}
  # devolve factorial de um numero n
  def factorial(n):
    if n==0:
      return 1
    if n>0:
      return n*factorial(n-1)

  # devolve o comprimento de uma lista
    def comprimento(lista):
      if lista==[]:
        return 0
      return 1+comprimento(lista[1:])
\end{lstlisting}

\begin{flushleft}
  Esta última função, vai funcionar da seguinte forma:
\end{flushleft}

\begin{lstlisting}
  comprimento([1, 2, 3])
  =
  1 + comprimento([2, 3])
  =
  1 + (1 + comprimento([3]))
  =
  1 + (1 + (1 + comprimento([])))
  =
  1 + (1 + (1 + 0))
  =
  3
\end{lstlisting}

\begin{lstlisting}
  # verifica se um elemento e membro de uma lista
  def membro(x,lista):
    if l==[]:
      return False
    return (lista[0]==x) or membro(x,lista[1:])
\end{lstlisting}

\pagebreak

\begin{lstlisting}

  # devolve uma lista com os elementos da lista de entrada por ordem inversa
  def inverter(lista):
    if lista==[]:
      return []
    inv = inverter(lista[1:])
    inv[len(inv):] = [lista[0]]
    return inv
\end{lstlisting}

\subsection{Expressões lambda}

São \textbf{expressões cujo valor é uma função}. Funções que recebem expressões lambda como
entrada e as retornam como saída chamam-se funções de ordem superior. Exemplo:

\begin{lstlisting}
  lambda x: x*x

  # Pode ser atribuida a uma variavel
  m = lambda x,y: math.sqrt(x**2 + y**2)
  m(1, 2) # 2.23606797749979
\end{lstlisting}

Como qualquer objeto, uma expressão lambda pode ser passada como:

\begin{lstlisting}
  # Tendo uma func h que produz f(x)*X
  def h(f, x): return f(x)*x

  # Para usar:
  h(lambda x: x+1, 7) # 56
\end{lstlisting}

Podem ser produzidas por outras funções:

\begin{lstlisting}
  def faz_incrementador(n):
    return lambda x: x+n

  # Para usar:
  f = faz_incrementador(1)
  f(10) # 11
\end{lstlisting}

As expressões lambda são tembém conhecidas como \uline{expressões funcionais}.
As funções que recebem estas expressões como entrada e/ou produzem expressões
lambda como saída chamam-se \uline{funções de ordem superior}.

\begin{flushleft}
  \textbf{Nota importante:} As expressões lambda só são
  úteis enquanto são simples. Uma função
  complexa merece ser escrita de forma clara
  numa definição (def) à parte.
\end{flushleft}

\pagebreak

\subsection{Aplicar uma função a uma lista}

Para tal podemos usar a função \textbf{map()}, predefinida em Python,
retorna um iterador que pode ser convertido numa lista. Esta função é
equivalente a:

\begin{lstlisting}
  def aplicar(funcao, lista):
    if lista==[]:
      return []
    return [funcao(lista[0])] + aplicar(funcao, lista[1:])
\end{lstlisting}

\subsection{Filtrar uma lista}

Para tal podemos usar a função \textbf{filter()}, predefinida em Python,
retorna um iterador que pode ser convertido numa lista. Esta função é
equivalente a:

\begin{lstlisting}
  def filtrar(funcao, lista):
    if lista==[]:
      return []
    if funcao(lista[0]):
      return [lista[0]] + filtrar(funcao, lista[1:])
    return filtrar(funcao, lista[1:])
\end{lstlisting}

\subsection{Reduzir uma lista a um valor}

Muitos dos procedimentos aplicados a listas consistem em combinar a cabeça da lista com o
resultado da chamada recursiva sobre os restantes elementos, retornando um valor “neutro”
pré-definido para a lista vazia. Em Python, podemos usar a função \textbf{reduce()} da
biblioteca \textbf{functools}.

\begin{center}
  \includegraphics[scale=0.3]{5}
\end{center}

\begin{lstlisting}
  # Dada uma lista, uma func de combinacao e um elemento neutro
  def reduzir(lista, fcomb, neutro):
    if lista==[]:
      return neutro
    return fcomb(lista[0], reduzir(lista[1:], fcomb, neutro))
\end{lstlisting}

\pagebreak

\subsection{Listas por compreensão (list comprehension)}

São mecanismos compactos para processar os elementos de uma lista (alguns ou todos), podendo ser aplicadas
não só a estas como também a tuplos ou cadeias de caracteres (str), o resultado é uma lista. Podem funcionar com a
função pré-definida \textbf{map()} ou \textbf{filter()}.

\[<expr> \textbf{for} <var> \textbf{in} <seq> \textbf{if} <condition>\]

\begin{lstlisting}
  [x**2 for x in [2, 3, 4]] # Output: [4, 9, 16]
  map(lambda x: x**2, [2, 3, 4]) # Igual

  [x for x in [2, 3, 4] if x%2==0] # Output: [2, 4]
  filter(lambda x: x%2==0, [2, 3, 4]) # Igual
\end{lstlisting}

Dada uma lista de listas e uma função, podemos aplicar uma função
a cada um dos elementos das listas, retornando a concatenação
das listas resultantes.

\begin{lstlisting}
  [f(y) for x in lista for y in x]

  # Exemplo:
  lista = [[1, 2, 3], [4, 5, 6]]
  [x+1 for x in lista for y in x] # [2, 3, 4, 5, 6, 7]
\end{lstlisting}

\subsection{Classes}

Tal como nas restantes linguagens Orientadas a Objetos (OO), em Python uma classe define
um conjunto de objetos caracterizados por diversos atributos e métodos e organizam-se numa
hierarquia que permite a herança.

\begin{lstlisting}
  # sintaxe
  class <nome-classe>:
    <decl-1>
    ...
    <decl-n>
\end{lstlisting}

\begin{flushleft}
  \textbf{Nota:} Tal como acontece com as variáveis normais, também
  os atributos das classes \uline{não são declarados}. Os atributos são
  acessados através da notação "objeto.atributo". Podemos, em qualquer momento,
  criar um novo atributo para um objeto, bastando para isso atribuir-lhe um valor.
\end{flushleft}

Existe ainda classes derivadas/herança, que herdam os métodos e atributos da
classe mãe, sendo possível uma classe ter várias classes mães.

\pagebreak

\subsubsection{Métodos e atributos pré-definidos}

\begin{flushleft}
  \textbf{Métodos:}
  \begin{itemize}
    \item \textbf{\_\_init\_\_} - Construtor da classe;
    \item \textbf{\_\_str\_\_} - Conversão para cadeia de caracteres;
    \item \textbf{\_\_repr\_\_} - Representação em cadeia de caractéres
    que aparece na consola do interpretador;
  \end{itemize}

  \textbf{Atributos:}
  \begin{itemize}
    \item \textbf{\_\_class\_\_} - identifica a classe de um dado objecto
  \end{itemize}
\end{flushleft}

\subsubsection{list de Python é uma classe}

\begin{flushleft}
  Tem os seguintes métodos:
  \begin{itemize}
    \item \textbf{append(x)} - Adiciona x ao fim da lista;
    \item \textbf{extend(L)} - Adiciona os elementos da lista L ao fim da lista;
    \item \textbf{insert(i, x)} - Adiciona x na posição i da lista;
    \item \textbf{remove(x)} - Remove a primeira ocorrência de x na lista;
    \item \textbf{index(x)} - Devolve o índice da primeira ocorrência de x na lista;
    \item \textbf{sort()} - Ordena a lista (modifica a lista);
  \end{itemize}
\end{flushleft}

\section{Tópicos de Inteligência Artificial}

\end{document}